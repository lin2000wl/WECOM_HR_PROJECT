---
description: 
globs: 
alwaysApply: true
---
# 应用流程文档：微信智能招聘机器人

本文档详细描述了微信智能招聘机器人的两个核心流程：用户交互流程（处理招聘查询）和简历处理流程（处理和入库简历）。

## 1. 用户交互流程 (在线处理)

```mermaid
graph TD
    A[收到企业微信回调 (HTTP POST)] --> Decrypt[解密/验签消息];
    Decrypt --> CheckAuth{发送者UserID是否授权?};
    Decrypt -- 验签/解密失败 --> Z[结束/记录错误];
    CheckAuth -- 否 --> Z;
    CheckAuth -- 是 --> CheckIntent{是否招聘查询意图? (解析消息内容)};
    CheckIntent -- 否 --> CheckIfWaiting{是否在等待用户选择? (查缓存 by UserID)};
    CheckIntent -- 是 --> StartQuery[启动新查询处理线程];
    StartQuery --> E[指令结构化 (调用LLM - v3 Prompt: 支持 education_levels, previous_companies)];
    E --> F{LLM解析成功? (parsed_data)};
    F -- 否 --> G[通过企微API发送错误提示给用户];
    G --> ExitThread[线程结束];
    F -- 是 --> H[构建DB查询条件 (mongo_query - v2 Logic: 处理范围/同义词/歧义/公司)];
    H --> I{查询条件有效?};
    I -- 否 --> J[通过企微API发送追问/错误提示];
    J --> ExitThread;
    I -- 是 --> K[数据库检索候选人池 (limit=M)];
    K --> L{找到匹配候选人? (pool)};
    L -- 否 --> M[通过企微API发送'未找到'提示];
    M --> ExitThread;
    L -- 是 --> ScoreSort[评分与排序 (pool, parsed_data, rules)];
    ScoreSort --> SelectTopN[选择Top N结果 (top_n)];
    SelectTopN --> GenSummary[调用 LLM 为 Top N 生成摘要];
    GenSummary --> FormatMsg[格式化 Top N 结果+摘要+选项];
    FormatMsg --> CacheState[缓存上下文/TopN结果/路径/映射/偏移量/has_more (设置 TTL, Key=UserID)];
    CacheState --> SendList[通过企微API发送 Top N 消息给用户];
    SendList --> ExitThread;

    CheckIfWaiting -- 否 --> Z;
    CheckIfWaiting -- 是 --> StartSelection[启动选择处理线程];
    StartSelection --> P{解析用户回复指令? (简历/信息/联系/A/B)};
    P -- 简历 X --> ReqResume[处理"简历 X"请求];
    ReqResume --> UploadResume[通过企微API上传简历获取media_id];
    UploadResume --> SendResume[通过企微API发送文件(media_id)];
    SendResume --> RefreshTTL[保持等待 (刷新TTL)];
    RefreshTTL --> ExitThread;
    P -- 信息 X --> ReqInfo[处理"信息 X"请求];
    ReqInfo --> SendInfo[从缓存获取信息, 格式化并通过企微API发送];
    SendInfo --> RefreshTTL;
    P -- 联系 X --> ReqContact[处理"联系 X"请求];
    ReqContact --> SendContactMsg[从缓存获取联系方式, 通过企微API发送沟通消息];
    SendContactMsg --> SendConfirm[通过企微API向用户发送确认消息];
    SendConfirm --> ClearCache[清除缓存];
    ClearCache --> ExitThread;
    P -- 'A' --> ReqMore[处理"A"请求 (查看更多)];
    ReqMore --> CheckHasMore{缓存中 has_more 为 True?};
    CheckHasMore -- 否 --> SendNoMore[通过企微API发送'无更多'提示, 清缓存];
    SendNoMore --> ExitThread;
    CheckHasMore -- 是 --> FetchNextPage[调用 _fetch_and_send 获取下一页 (offset, parsed_data)];
    FetchNextPage --> PageSent{成功发送下一页?};
    PageSent -- 是 --> ExitThread;
    PageSent -- 否 --> SendNoMore;

    P -- 'B' --> ReqEnd[处理"B"请求 (结束查询)];
    ReqEnd --> SendEndConfirm[通过企微API发送结束确认, 清缓存];
    SendEndConfirm --> ExitThread;
    P -- 无效/超时/其他 --> InvalidInput[处理无效输入或超时];
    InvalidInput --> SendInvalidHint[通过企微API发送提示, 清缓存 (如果是超时)];
    SendInvalidHint --> ExitThread;


    subgraph 企业微信回调处理 (FastAPI)
        A
        Decrypt
    end
    subgraph 并发处理 (线程池)
        StartQuery
        StartSelection
    end
    subgraph LLM Interaction
        E
        GenSummary
    end
    subgraph DB Interaction
        K
    end
    subgraph Scoring & Sorting
         ScoreSort
         SelectTopN
    end
    subgraph User Interaction (via Enterprise WeChat API)
        G
        J
        M
        SendList
        P
        SendInfo
        SendConfirm
        SendNoMore
        SendEndConfirm
        SendInvalidHint
        UploadResume
        SendResume
    end
    subgraph Candidate Interaction (via Enterprise WeChat API)
        SendContactMsg
    end
    subgraph Cache Interaction (State Manager with TTL)
        CheckIfWaiting
        CacheState
        ReqResume
        ReqInfo
        ReqContact
        ReqMore
        RefreshTTL
        ClearCache
        SendNoMore
        SendEndConfirm
        SendInvalidHint
        FetchNextPage
    end

```

此流程由企业微信回调触发，处理已授权用户的招聘查询请求。机器人会返回**评分排序后的 Top N** 候选人列表及自动摘要，并提供选项让用户按需获取详细信息、简历、联系候选人、放弃或查看**下一页**结果。通过企业微信API与用户交互，具备并发处理能力和状态超时。

**(触发: 收到企业微信回调 HTTP POST 请求)**

1.  **消息接收与初步判断 (FastAPI 应用 - 主线程/请求处理):**
    *   FastAPI 应用接收到来自企业微信服务器的 HTTP POST 请求。
    *   从请求中获取加密的消息体以及签名、时间戳、nonce 等参数。
    *   使用 `WXBizMsgCrypt` 进行消息解密和签名校验。
        *   **失败:** 记录严重错误，向企业微信服务器返回错误响应或空字符串。流程终止。
    *   将解密后的 XML 消息转换为 Python 字典 (`decrypted_msg_dict`)。
    *   从字典中提取发送者 `UserID` (`FromUserName`)、消息类型 (`MsgType`)、消息内容 (`Content`) 等。
    *   **立即响应企业微信:** 向企业微信服务器返回一个空字符串或特定成功标识，表示已成功接收，避免重试。

2.  **用户授权校验 (核心处理器 - 分发前):**
    *   **查询授权列表:** 检查发送者 `UserID` 是否存在于预先配置的授权用户列表 (`config_ew.AUTHORIZED_USER_IDS`)。
    *   **未授权:** 如果发送者未授权，记录日志。流程终止（后续处理不再进行）。

3.  **请求分发 (核心处理器 - 消息分发器):**
    *   **判断意图/状态:**
        *   检查消息内容是否符合新的招聘查询意图 (例如，通过关键词或简单规则判断是否是文本消息且非特定指令)。
        *   如果不是新查询，检查状态管理器中是否存在该 `UserID` 的等待状态 (使用 `UserID` 作为 key)。
    *   **分发任务:**
        *   如果是新的有效查询请求，从线程池获取一个工作线程，并将 `decrypted_msg_dict` 和相关信息传递给 **步骤 4 (查询处理线程)**。
        *   如果是处于等待状态用户的有效回复，从线程池获取一个工作线程，并将 `decrypted_msg_dict` 和用户的缓存状态传递给 **步骤 11 (选择处理线程)**。
        *   其他情况（非查询、非等待回复、无效请求等），忽略或按需处理。

**--- 查询处理线程 (处理新查询) ---**

4.  **查询指令结构化 (LLM 服务模块):**
    *   准备 Prompt (**已更新，支持 education_levels, previous_companies**)，调用 LLM API 解析用户指令 (`decrypted_msg_dict['Content']`)，提取结构化条件 (`parsed_data`)。
    *   处理 LLM 响应和错误。
    *   **失败/异常:** 通过企业微信 API 向用户发送错误提示。线程结束。

5.  **查询条件校验与构建 (数据库交互模块):**
    *   **[修改]** 校验 `parsed_data`，调用 `_build_mongo_query` 构建 MongoDB 查询条件 (`mongo_query`)。
        *   `_build_mongo_query` **已更新**，可以处理学历范围和同义词（查询 `query_tags.degrees` using `$in`），处理证书模糊匹配（查询 `query_tags.certifications` using `$regex`），处理职位/证书歧义（使用 `$or` 联合查询 `positions`/`certifications`），处理公司经验（查询 `extracted_info.experience.company` using `$regex`）。
    *   **失败/信息不足:** 通过企业微信 API 向用户发送追问或错误提示。线程结束。

6.  **数据库检索候选人池 (数据库交互模块):**
    *   使用 `mongo_query` 在 MongoDB 中查询，获取一个初步候选人池 (limit=M)。
    *   **未找到:** 通过企业微信 API 向用户发送'未找到'提示。线程结束。
    *   **找到 (列表 pool):** 继续下一步。
    *   **数据库错误:** 记录日志，通过企业微信 API 发送提示。线程结束。

7.  **评分与排序 (评分工具 & 核心逻辑):**
    *   加载评分规则。
    *   调用评分函数，计算候选人池中每个候选人的得分。
    *   根据得分对候选人池进行降序排序。

8.  **选择 Top N (核心逻辑):**
    *   从排序后的列表中选取前 N 个候选人。

9.  **生成简要对比分析 (LLM 服务模块):**
    *   准备 Prompt，传入 `parsed_data` 和 **Top N** 候选人的简要信息。
    *   调用 LLM API 生成简短的对比分析摘要。
    *   处理 LLM 响应和错误 (如果失败，可以只发送列表，记录警告)。

10. **格式化与发送结果 (消息模块 & 状态管理器 & 企业微信服务模块):**
    *   格式化包含 **Top N** 候选人列表、编号、LLM 摘要和操作指令提示的消息。
    *   **缓存状态:** 将 `mongo_query`, `parsed_data`, **Top N** 结果信息、下次偏移量、是否有更多标记存入状态管理器 (key 为 `UserID`)，设置 TTL。
    *   **发送消息:** 调用 `enterprise_wechat_service` 将最终消息通过企业微信 API 发送给用户。
    *   线程结束。

**--- 选择处理线程 (处理等待中的用户回复) ---**

11. **处理用户选择 (指令解析模块 & 状态管理器):**
    *   **(触发: 收到处于等待状态用户的消息)**
    *   **获取缓存:** 从状态管理器获取该 `UserID` 的缓存上下文。
    *   **解析指令:** 解析消息内容 (`decrypted_msg_dict['Content']`)，判断属于哪种操作 (`简历 X`, `信息 X`, `联系 X`, `A`, `B`)。
    *   **处理无效回复:** 如果无法解析或指令无效，通过企业微信 API 向用户发送提示。线程结束。

12. **处理 `简历 X` 请求 (企业微信服务模块 & 状态管理器):**
    *   校验序号 X 有效性。
    *   从缓存获取 `resume_pdf_path`。
    *   调用 `enterprise_wechat_service.upload_temporary_media()` 上传简历文件，获取 `media_id`。
    *   调用 `enterprise_wechat_service.send_file_message()` 发送文件消息。
    *   处理文件不存在/上传失败/发送失败的情况。
    *   **刷新 TTL:** 更新缓存状态的 TTL。
    *   线程结束 (等待下一次输入)。

13. **处理 `信息 X` 请求 (消息模块 & 状态管理器 & 企业微信服务模块):**
    *   校验序号 X 有效性。
    *   从缓存获取 `extracted_info`。
    *   格式化为易读文本。
    *   调用 `enterprise_wechat_service.send_text_message()` 发送详细信息。
    *   **刷新 TTL:** 更新缓存状态的 TTL。
    *   线程结束 (等待下一次输入)。

14. **处理 `联系 X` 请求 (消息模块 & 状态管理器 & 企业微信服务模块):**
    *   校验序号 X 有效性。
    *   从缓存获取候选人联系方式 (如企业微信外部联系人ID)。
    *   调用 `enterprise_wechat_service.send_text_message()` (或特定联系接口) 发送预设沟通消息给候选人。
    *   处理发送失败。
    *   通过企业微信 API 向用户发送确认消息。
    *   **清除缓存:** 从状态管理器移除该 `UserID` 的状态。
    *   线程结束。

15. **处理 `A` (查看更多) 请求 (DB 交互 & 核心逻辑 & 状态管理器 & 企业微信服务模块):**
    *   从缓存获取 `mongo_query`, `parsed_data`, `next_offset`, `has_more`。
    *   **如果 `has_more` 为 True:**
        *   调用 `_fetch_and_send_candidates` 函数，传入 `mongo_query`, `next_offset`, `parsed_data`。
        *   该函数内部会处理获取（可能需要重新评分排序或直接分页）、通过企业微信 API 发送下一页 Top N 结果和更新缓存状态。
    *   **如果 `has_more` 为 False 或 `_fetch_and_send_candidates` 未找到更多结果:**
        *   通过企业微信 API 发送 '无更多' 提示给用户。
        *   清除缓存。
    *   线程结束。

16. **处理 `B` (结束查询) 请求 (消息模块 & 状态管理器 & 企业微信服务模块):**
    *   通过企业微信 API 发送结束确认消息给用户。
    *   **清除缓存:** 从状态管理器移除该 `UserID` 的状态。
    *   线程结束。

17. **处理超时 (由状态管理器 TTL 触发，或单独的监控任务):**
    *   当缓存条目因 TTL 过期时，该用户的交互流程自动结束。
    *   (可选) 可以实现一个机制，在超时发生时通过企业微信 API 给用户发送一条提示消息。 ("您的操作已超时，请重新发起查询")

---

## 2. 简历处理流程 (后台/离线处理)

```mermaid
graph LR
    A[开始 (定时/手动/监控)] --> B[扫描 data/ 目录获取 PDF 列表];
    B --> C{循环处理每个PDF};
    C -- 文件 --> D[提取文本内容 (PDF/OCR)];
    D --> E{文本提取成功?};
    E -- 否 --> F[记录错误, 移至 error/];
    F --> NextFile;
    E -- 是 --> G[调用 LLM 解析简历];
    G --> H{LLM 解析成功?};
    H -- 否 --> I[记录错误, 移至 error/];
    I --> NextFile;
    H -- 是 --> J[校验关键信息 (姓名, 手机号)];
    J --> K{关键信息有效?};
    K -- 否 --> L[记录问题, 移至 pending/];
    L --> NextFile;
    K -- 是 --> M[标准化文件名 (处理重名)];
    M --> N[移动/重命名文件至 processed_resumes/];
    N --> O{文件操作成功?};
    O -- 否 --> P[记录严重错误 (需人工介入)];
    P --> NextFile;
    O -- 是 --> Q[数据入库 (Upsert DB)];
    Q --> R{数据库操作成功?};
    R -- 否 --> S[记录严重错误 (数据不一致, 需人工介入)];
    S --> NextFile;
    R -- 是 --> T[记录处理成功日志];
    T --> NextFile;
    NextFile --> C;
    C -- 完成所有文件 --> Z[结束];

    subgraph File Operations
        B
        D
        F
        I
        L
        M
        N
        P
    end
    subgraph LLM Service
        G
    end
    subgraph Database Operations
        Q
        S
    end
    subgraph Logging
        F
        I
        L
        P
        S
        T
    end
```

此流程独立于用户交互，用于处理 `data/` 目录下的简历文件，提取信息、标准化文件名并存入数据库。

**(触发: 定时任务 / 手动执行 / 目录监控)**

1.  **扫描简历目录 (文件处理模块):**
    *   获取配置的简历数据目录路径 (`data/`)。
    *   遍历该目录下（可配置是否递归）的所有 PDF 文件。对每个找到的文件执行后续步骤。

2.  **a. 提取文本内容 (PDF/OCR 模块):**
    *   尝试使用 PDF 解析库 (如 `PyPDF2`, `pdfminer.six`) 直接提取 PDF 文件的文本内容。
    *   如果提取文本为空或效果不佳，调用 OCR 工具 (如 `pytesseract`) 进行文字识别。
    *   **处理失败:** 标记该文件处理失败，记录错误日志，移至 `data/error/`。跳过后续步骤。

3.  **b. 调用 LLM 提取信息 (LLM 服务模块):**
    *   准备 Prompt，包含提取出的文本。
    *   处理长文本（截断、分块等）。
    *   调用 LLM API 进行简历解析。
    *   **处理失败/异常:** 标记文件处理失败，记录错误日志，移至 `data/error/`。跳过后续步骤。

4.  **c. 校验关键信息 (数据处理模块):**
    *   检查 JSON 数据中是否包含有效的"姓名" (`name`) 和"手机号码" (`phone`)。
    *   **校验失败:** 标记文件为"待人工处理"，记录日志，移至 `data/pending/`。跳过后续步骤。

5.  **d. 标准化文件名 (文件处理模块):**
    *   获取姓名和手机号后四位，构建基础文件名 `姓名+手机号后四位.pdf`。
    *   确定目标目录 `processed_resumes/`。
    *   检查并处理重名（添加后缀）。
    *   获取最终目标文件路径。

6.  **e. 文件重命名/移动 (文件处理模块):**
    *   尝试将原始 PDF 文件移动并重命名到最终路径。
    *   **处理文件操作错误:** 记录严重错误日志，需要人工检查。

7.  **f. 数据入库 (数据库交互模块):**
    *   准备数据：整合 LLM 提取的 JSON 信息和最终文件路径。
    *   使用姓名和手机号作为唯一标识，执行 MongoDB Upsert 操作。
    *   **处理数据库错误:** 记录严重错误日志，可能导致数据不一致，需后续检查。

8.  **g. 记录处理结果 (日志模块):**
    *   记录成功处理文件的日志。

9.  **流程结束:**
    *   处理完目录下所有文件后结束。
    *   (可选) 生成统计报告。

