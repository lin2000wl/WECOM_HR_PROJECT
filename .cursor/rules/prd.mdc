---
description: 
globs: 
alwaysApply: true
---
# PRD 文档：微信智能招聘机器人 (基于 wcferry)

## 1. 引言

### 1.1 目的

本文档旨在明确微信智能招聘机器人的产品需求，作为后续设计、开发、测试和部署的依据。该机器人利用企业微信自建应用框架，在企业微信环境中实现自动化、智能化的候选人筛选与初步沟通，提高招聘效率。

### 1.2 项目背景

传统招聘流程中，从海量简历中筛选合适候选人并进行初步沟通耗时耗力。本机器人旨在通过自动化处理，快速响应招聘需求，精准匹配候选人，并启动初步联系，减轻招聘人员的负担 (基于企业微信生态)。

### 1.3 范围

*   机器人能够接收指定招聘人员（以下简称"用户"）通过企业微信应用发送的候选人查询指令。
*   机器人能够解析查询指令中的关键信息（如职位、工作年限、**学历范围、公司经验、证书**等，**并处理部分同义词和歧义**）。
*   机器人能够根据解析出的条件，在候选人数据库中进行检索（**学历使用 $in 匹配，证书/公司使用 $regex 模糊匹配，职位/证书歧义使用 $or 联合查询**）。
*   **[新增]** 机器人内部会根据预设规则对匹配的候选人进行打分和排序。
*   机器人能够将**得分最高的 N 位**候选人列表（关键信息摘要和自动生成的简要对比分析）发送给用户以供选择。
*   用户选择特定候选人后，机器人能够自动向该候选人发送预设的初步沟通消息。
*   用户可以按需请求获取特定候选人的详细信息或简历 PDF 文件。
*   机器人能够处理 `data` 目录下的 PDF 格式简历：进行文件名标准化、提取关键信息并存入数据库。
*   机器人需稳定运行，具备并发处理能力和用户状态超时管理，并能处理基本的交互流程和简历处理流程。

### 1.4 名词解释

*   **用户 (User):** 指有权限使用此机器人进行招聘查询的招聘人员或 HR (通过其企业微信 UserID 识别)。
*   **候选人 (Candidate):** 指存储在数据库中，等待被匹配和联系的求职者 (可能通过企业微信外部联系人等方式触达)。
*   **查询指令 (Query Command):** 用户通过企业微信应用发送给机器人的，包含职位和筛选条件的消息。
*   **`wcferry`:** 一个用于操作微信 PC 版客户端的 Python 库。 (此项为旧版技术，当前版本已迁移至企业微信框架)
*   **企业微信自建应用框架:** 利用企业微信提供的 API 和回调机制构建应用。
*   **候选人数据库 (Candidate Database):** 存储候选人信息的数据库（MongoDB），包含从简历提取的信息和简历文件路径。
*   **简历 (Resume):** 指存储在 `data` 目录下的 PDF 格式的候选人履历文件。
*   **简要对比分析 (Brief Comparison Summary):** 由 LLM 自动生成的，对当前批次候选人与查询指令匹配度的简短评分和优势说明。
*   **状态管理器 (State Manager):** 用于缓存用户交互过程中的临时数据（如查询上下文、候选人映射），并具有 TTL (Time-To-Live) 超时机制。

## 2. 产品目标

*   **提高效率:** 自动化候选人筛选和初步联系过程，缩短招聘周期。
*   **精准匹配:** 基于用户指令，准确检索数据库中符合条件的候选人。
*   **及时响应:** 快速响应用户的查询需求（支持并发处理）。
*   **简化流程:** 为招聘人员提供便捷的微信端操作界面（支持私聊和群聊）。
*   **智能辅助:** 提供自动生成的候选人简要对比分析。

## 3. 用户角色

*   **招聘人员 (Recruiter):** 主要使用者，通过企业微信应用向机器人发送查询指令，接收候选人列表（含摘要）和简要对比分析，按需获取详细信息/简历，并选择目标候选人进行联系。
*   **候选人 (Candidate):** 接收由机器人代发的初步沟通消息 (通过企业微信或用户选择的其他方式)。
*   **管理员 (Admin):** (可选) 负责机器人的部署、配置（如授权用户列表 `AUTHORIZED_USER_IDS_EW`、数据库连接、LLM Key、企业微信应用参数）、监控和维护。

## 4. 功能需求

### 4.1 核心流程 (用户交互)

1.  **启动与回调监听:** 机器人后端服务 (FastAPI 应用) 启动，监听企业微信服务器的回调请求，并初始化 `CoreProcessor`（包含 `ThreadPoolExecutor` 用于并发处理）。
2.  **指令识别与鉴权:**
    *   接收到企业微信回调消息后，进行解密和验签。
    *   `CoreProcessor` 从解密消息中获取发送者 `UserID` (`FromUserName`)。
    *   `CoreProcessor` 调用 `AuthHandlerEw` 判断发送者 `UserID` 是否为已授权的招聘人员 (基于 `config_ew.AUTHORIZED_USER_IDS_EW`)。
    *   `CoreProcessor` 识别消息是否为招聘查询意图或对先前结果的响应。
    *   `CoreProcessor` 将通过校验的有效请求（消息内容和用户ID）提交到其内部的 `ThreadPoolExecutor` 中，由一个独立的任务（`_process_message_task_async`）进行后续异步处理。
3.  **指令解析 (使用 LLM):**
    *   在 `CoreProcessor` 的异步任务 (`_handle_new_query_task`) 中，调用 `LLMClient` 的 `parse_query_intent` 方法。
    *   将用户自然语言查询指令发送给大语言模型（LLM，如 DeepSeek）进行处理。
    *   **[修改]** 通过精心设计的 Prompt，引导 LLM 从指令中提取结构化的关键信息，例如：
        *   职位名称 (`position`)
        *   工作经验要求 (`experience_years_min`, `experience_years_max`)
        *   **[修改]** 学历要求 (`education_levels`: 列表，能处理"本科以上"等范围，并输出如 `["本科", "硕士", "博士"]`)
        *   技能标签 (`skills`)
        *   所在地 (`location`)
        *   要求的证书 (`certifications`)
        *   **[新增]** 要求的过往公司经验 (`previous_companies`: 列表)
    *   预期 LLM 返回标准化的数据格式（如 JSON）。
    *   如果 `LLMClient` 解析失败或返回无效数据，`CoreProcessor` 会向用户发送提示并清除当前会话状态。
4.  **数据库检索 & **[新增] 评分与排序:**
    *   **[修改]** 在 `CoreProcessor` 的异步任务 (`_handle_new_query_task`) 中，根据 `LLMClient` 返回的 `parsed_data`，调用内部的 `_build_mongo_query` 方法构建 MongoDB 查询 (`mongo_query`)：
        *   **学历:** 使用 `$in` 操作符匹配 `parsed_data['education_levels']` 列表中的任何一项，查询 `query_tags.degrees` 字段，并自动扩展 "本科"/"学士" 同义词。
        *   **证书:** 对 `parsed_data['certifications']` 中的每个证书，使用 `$regex` 对 `query_tags.certifications` 数组进行模糊匹配。 （具体逻辑在 `_build_mongo_query` 中实现）
        *   **职位/证书歧义:** 如果提供了 `parsed_data['position']`，使用 `$or` 条件同时模糊匹配 `query_tags.positions` 和 `query_tags.certifications`。
        *   **公司经验:** 如果提供了 `parsed_data['previous_companies']`，使用 `$regex` 模糊匹配 `extracted_info.experience.company` 字段。
        *   内部 `_expand_skills` 方法用于技能同义词扩展。
        *   其他字段（经验、技能、地点）按相应逻辑构建查询。
    *   如果构建的 `mongo_query` 无效，`CoreProcessor` 会向用户发送提示并清除状态。
    *   **[修改]** `CoreProcessor` 调用 `DBInterface` 的 `find_candidates` 方法查询候选人数据库。获取一个比最终展示数量 N 更大的初步候选人池 M (例如 M=30，数量可配置)。
    *   **[新增]** (占位) 加载配置文件中的**评分规则**。
    *   **[新增]** (占位) 对 M 个候选人进行**内部评分计算**。
    *   **[新增]** (占位) 根据分数对 M 个候选人进行**降序排序**。
    *   **[新增]** 选择排序后的**前 N 个** (例如 N=5) 候选人作为最终结果。
    *   如果未查询到候选人，`CoreProcessor` 会向用户发送提示并清除状态。
5.  **[v1.1 调整] 结果反馈与自动摘要:**
    *   在 `CoreProcessor` 的异步任务 (`_handle_new_query_task`) 中获取查询结果的前 N 个（例如最多 5 个）候选人。
    *   **[v1.1 新增]** `CoreProcessor` 调用 `LLMClient` 的 `get_brief_comparison_summary` 方法，根据原始查询指令和这 N 个候选人的简要信息生成一份简要对比分析报告（评分+优势）。
    *   **[v1.1 调整]** 不再立即发送简历文件。
    *   `CoreProcessor` 格式化包含这 N 个候选人关键信息（姓名、摘要、技能等）的列表，并为每个候选人分配序号 (1, 2, 3...N)。
    *   将简要对比分析报告附加到列表消息中。
    *   在列表下方添加操作提示，明确告知用户可以回复的指令，例如：
        *   `简历 X`: 获取第 X 位候选人的简历文件。
        *   `信息 X`: 获取第 X 位候选人的详细信息。
        *   `联系 X`: 联系第 X 位候选人。
        *   `A`: 查看更多符合条件的候选人。
        *   `B`: 都不满意/结束本次查询。
    *   `CoreProcessor` 将包含列表、摘要、选项和提示语的最终文本消息通过企业微信API (`ew_service`) 发送给用户。
    *   **[v1.1 增强]** `CoreProcessor` 调用 `state_manager` (单例) 的 `update_state_and_cache_results` 方法缓存本次查询的上下文（查询条件、当前分页信息、候选人完整信息和简历路径、序号与候选人信息的映射，使用 `UserID` 作为主键），设置 TTL 超时（例如 3 分钟）。
6.  **[v1.1 重构] 用户选择处理:**
    *   在 `CoreProcessor` 的异步任务 (`_handle_follow_up_task`) 中监听用户的回复 (状态需要与 `state_manager` 缓存中的上下文关联，通过 `UserID` 关联)。
    *   **处理 `简历 X` 回复:** (占位实现 - 功能开发中)
        *   校验序号 X 的有效性，并从缓存中获取对应的 `resume_pdf_path`。
        *   调用企业微信API上传简历为临时素材，获取 `media_id`。
        *   调用企业微信API将文件消息 (基于 `media_id`) 发送给用户。
        *   处理文件不存在或发送失败的情况（记录日志，向用户发送提示）。
        *   保持用户状态，等待下一次操作或超时。
    *   **处理 `信息 X` 回复:** (占位实现 - 功能开发中)
        *   校验序号 X 的有效性，并从缓存中获取对应的候选人详细信息 (`extracted_info`)。
        *   将信息格式化为易读文本。
        *   使用企业微信API发送详细信息给用户。
        *   保持用户状态，等待下一次操作或超时。
    *   **处理 `联系 X` 回复:** (占位实现 - 功能开发中)
        *   校验序号 X 的有效性，并从缓存中获取对应的候选人联系方式 (如企微外部联系人ID或手机号等)。
        *   通过企业微信API (或引导用户手动操作) 向该候选人发送预设的初步沟通消息模板。
        *   处理发送失败（记录日志，可选通知用户）。
        *   向用户发送确认消息 (如: "已尝试联系候选人 [姓名]")。
        *   清除缓存的查询上下文，流程结束。
    *   **处理 'A' 回复 ("查看更多"):** (占位实现 - 功能开发中)
        *   从缓存中获取之前的查询条件和分页信息。
        *   执行数据库查询，获取下一页（下 N 个）的候选人。
        *   如果查询到新的候选人，重复 **步骤 5 ([v1.1 调整] 结果反馈与自动摘要)** 的逻辑，**更新**缓存。
        *   如果查询不到更多候选人，发送提示信息 (如："没有更多符合条件的候选人了。")，清除缓存的查询上下文，流程结束。
    *   **处理 'B' 回复 ("都不满意"):** (已初步实现)
        *   `CoreProcessor` 发送确认信息 (如："好的，已了解。如需新的查询，请重新发送指令。")。
        *   `CoreProcessor` 调用 `state_manager.clear_state(user_id)` 清除缓存的查询上下文，流程结束。
    *   **处理无效回复/超时:**
        *   **[v1.1 新增]** 通过 `state_manager` 的 TTL 机制检测超时。
        *   `CoreProcessor` 发送提示信息 ("您的操作已超时" 或 "请输入有效指令")。
        *   清除缓存的查询上下文，流程结束。

### 4.2 `wcferry` 相关功能

(本节内容已过时，当前版本基于企业微信自建应用框架，不再直接使用 `wcferry` 进行核心交互)

*   ~~**初始化与登录:** 使用 `wcferry` 初始化 Wcf 实例，确保微信客户端在线。 (`Wcf()`)。~~ 
*   ~~**消息接收:** 启用消息接收，推荐使用队列方式处理消息。 (`enable_receiving_msg()`, `get_msg()`)。~~ 
*   ~~**消息发送:**~~ 
    *   ~~向用户发送候选人列表、摘要和选择提示 (支持私聊和群聊 @)。 (`send_text()`)。~~ 
    *   ~~向用户发送详细信息。 (`send_text()`)。~~ 
    *   ~~向用户发送确认/提示信息。 (`send_text()`)。~~ 
    *   ~~向候选人发送初步沟通消息。 (`send_text()`)。~~ 
*   ~~**文件发送:** 按需向用户发送简历 PDF 文件。 (`send_file()`)。~~ 
*   ~~**获取用户信息:** 获取消息发送者的信息以进行权限验证，获取机器人自身 WxID (`get_self_wxid()`) 用于群聊 @ 判断。~~ 
*   ~~**群聊信息:** 获取群成员昵称 (`get_alias_in_chatroom()`) 用于 @ 回复。~~ 
*   ~~**程序退出处理:** 优雅退出时清理 `wcferry` 资源。 (`cleanup()`)。~~ 

### 4.2 企业微信交互功能 (替代原 wcferry 功能)

*   **回调处理:** 通过 FastAPI 应用接收和处理企业微信服务器的 HTTP 回调 (URL验证、消息接收)。
*   **消息加解密:** 使用 `WXBizMsgCrypt` 模块进行消息的解密和响应的加密。
*   **Access Token 管理:** 自动获取和刷新 `access_token`，用于调用企业微信 API。
*   **消息发送:** 
    *   使用企业微信 API (`message/send`) 发送文本消息给用户 (应用内消息)。
    *   发送给候选人的消息可能需要通过特定接口 (如外部联系人消息或客服消息，具体取决于实现方式)。
*   **文件发送:** 
    *   使用企业微信 API (`media/upload`) 上传文件为临时素材。
    *   使用 `message/send` API 发送文件消息 (基于 `media_id`)。
*   **获取用户信息:** 从回调消息中获取用户 `UserID` (`FromUserName`)。
*   **错误处理:** 处理企业微信 API 调用相关的错误。

### 4.3 配置管理

*   **授权用户列表:** 需要配置哪些企业微信用户（通过 `UserID`）有权限使用此机器人 (例如 `AUTHORIZED_USER_IDS_EW` 在 `.env` 文件中)。
*   **数据库连接信息:** 配置 MongoDB 的地址、用户名、密码等。
*   **消息模板:** 配置发送给候选人的初步沟通消息内容，允许包含占位符。
*   **LLM API 配置:** 配置 DeepSeek 的 API Endpoint, API Key 等信息。`LLMClient` 从 `config_ew.py` 读取 `LLM_QUERY_MODEL`, `LLM_RESUME_MODEL`, `LLM_SUMMARY_MODEL`。
*   **简历数据目录:** 配置存放原始 PDF 简历的目录路径 (如 `data/`) 和处理后/错误/待处理目录。
*   **[v1.1 新增]** 状态缓存 TTL 时间 (如 180 秒)。
*   **企业微信应用配置:** CorpID, AgentID, App Secret, Callback Token, Callback AESKey (在 `.env` 文件中，由 `config_ew.py` 加载)。

### 4.4 错误处理与日志

*   **无效指令/回复:** 对于无法识别或解析的指令/回复（包括 LLM 解析失败、无效序号、非预期文本），向用户发送提示信息。
*   **无匹配结果:** 数据库查询无结果时，告知用户未找到符合条件的候选人。
*   **发送失败:** 向候选人或用户发送消息/文件失败时 (通过企业微信 API)，记录日志并可选择性地通知用户。
*   **数据库错误:** 数据库连接或查询异常时，记录详细错误日志。
*   **`wcferry` 异常:** (此条在企业微信版中不再适用)
*   **企业微信 API 错误:** 处理调用企业微信 API 时可能出现的网络错误、超时、认证失败 (`access_token` 无效)、权限不足、速率限制等问题。记录错误并可能向用户反馈稍后再试或通知管理员。
*   **企业微信回调处理错误:** 确保回调服务器能正确处理加解密、验签，并对企业微信服务器做出及时响应，记录内部处理错误。
*   **LLM API 错误:** `LLMClient` 包含重试逻辑。`CoreProcessor` 在调用 `LLMClient` 后会检查结果，并在出错时向用户发送提示。
*   **LLM 解析质量问题:** 对于 LLM 返回结果不准确或与预期偏差较大的情况（查询、简历、摘要），记录原始输入和 LLM 输出，便于分析和优化 Prompt。**特别注意：尽管 Prompt 已优化，LLM 在解析复杂的范围查询（如学历）、同义词（如本科/学士）、歧义词（职位vs证书）时仍可能出错。**
*   **简历处理错误:** (后台流程)
    *   PDF 文件损坏或无法读取。
    *   LLM 无法从简历中提取必要信息。
    *   文件重命名/移动失败。
    *   数据库写入简历信息失败。
*   **[v1.1 新增]** 并发处理异常:** `CoreProcessor` 的 `_process_message_task_sync_wrapper` 和 `_process_message_task_async` 包含顶层异常捕获和日志记录。
*   **[v1.1 新增] 缓存错误:** `StateManager` 本身是线程安全的。`CoreProcessor` 在使用 `state_manager` 时，错误主要由 `state_manager` 内部或业务逻辑处理。
*   **日志记录:** 记录关键操作日志，包括收到的消息（来源、内容）、权限校验结果、意图识别、LLM 调用（类型、输入、输出）、数据库操作、文件处理、状态缓存操作（增删改查、命中、过期）、消息/文件发送动作及结果等，便于问题排查。

### 4.5 简历处理流程 (建议离线/后台执行)

(此流程基本保持不变，但需确保与 v1.1 的数据库模型和 `db_interface` 兼容)

1.  **触发方式:** 可通过定时任务、手动触发或目录监控等方式启动简历处理流程。
2.  **遍历简历目录:** 扫描配置的简历数据目录 (`data/`) 下的 PDF 文件。
3.  **信息提取 (使用 LLM):**
    *   对于每个 PDF 文件，提取其文本内容（如果 PDF 本身是文本可选，如果是图片需要 OCR）。
    *   将提取的文本发送给配置好的 LLM (如 DeepSeek) 进行简历解析。
    *   Prompt 应指示 LLM 提取关键信息（姓名、手机号、邮箱、当前地址、工作经历、教育背景、技能、证书等）。
    *   LLM 返回结构化的数据（如 JSON）。
4.  **处理与重命名:**
    *   校验关键信息 (姓名, 手机号)。
    *   提取失败处理 (移至 error/ 或 pending/)。
    *   提取成功处理：生成标准化文件名 (`姓名+手机号后四位.pdf`)，处理冲突，移动/重命名文件到 `processed_resumes/`。
5.  **数据入库:**
    *   将提取的结构化信息和标准化后的简历文件路径存入候选人数据库 (MongoDB)，使用 Upsert 方式。
6.  **状态反馈/日志:** 记录每个文件处理成功、失败或需要人工干预的状态。

## 5. 非功能需求

*   **性能:**
    *   机器人应能快速响应用户查询。整体响应时间（从接收指令到返回列表和摘要）应尽量控制在用户可接受范围内（目标 5-15 秒）。
    *   **[v1.1 新增]** 并发处理能力：系统应能同时处理多个用户的请求而不会显著阻塞或降低响应速度（具体并发数取决于部署环境资源）。
*   **可靠性:**
    *   机器人应能 7x24 小时稳定运行。
    *   具备一定的异常自恢复能力（如 LLM API/DB 临时不可用时的重试）。
    *   **[v1.1 新增]** 状态管理应可靠，TTL 机制能按预期工作。
*   **易用性:**
    *   用户查询指令应尽可能自然。**（已改进对学历范围、公司经验等的支持）**
    *   反馈信息（列表、摘要、提示）清晰易懂，操作指令明确。
    *   **[v1.1 新增]** 在私聊和群聊 @ 场景下交互逻辑一致。
*   **安全性:**
    *   仅授权用户可使用查询功能。
    *   数据库连接信息和 LLM API Key 等敏感信息需妥善保管。
    *   候选人敏感信息（如联系方式）需妥善处理。
    *   防止恶意指令注入或滥用。
    *   关注将用户查询和简历信息发送给第三方 LLM API 的数据隐私和安全政策。
*   **可维护性:** 代码结构清晰，配置与逻辑分离，日志完善，便于后期维护和升级。LLM 的 Prompt 应易于调整。

## 6. 技术选型与实现考虑

*   **核心框架:** Python + FastAPI (用于企业微信回调和 API 服务) + Uvicorn (ASGI 服务器)。
*   **企业微信交互:**
    *   `httpx`: 用于异步调用企业微信服务端 API。
    *   `pycryptodome`: `WXBizMsgCrypt` 的依赖，用于消息体加解密。
    *   `xmltodict`: 用于解析企业微信回调的 XML 消息。
*   **数据库:** MongoDB (使用 `pymongo` 驱动)。
*   **指令解析/简历解析/自动摘要:** DeepSeek LLM API (通过 `openai` 库调用)。
*   **PDF 处理:** `PyPDF2` / `pdfminer.six` (文本提取), `pytesseract` (OCR)。
*   **配置管理:** YAML (`PyYAML`) 或 `.env` (`python-dotenv`)。
*   **日志:** Python 内建 `logging`。
*   **[v1.1 新增] 并发处理:** Python 内建 `threading` 模块 (`ThreadPoolExecutor` 在 `CoreProcessor` 中使用)。
*   **[v1.1 新增] 状态缓存与 TTL:** `cachetools.TTLCache` (在 `state_manager` 单例中使用，配置通过 `config_ew.py` 加载)。
*   **部署:** 
    *   服务器环境 (Linux 或 Windows)。
    *   需要公网 IP 和可配置的域名 (用于企业微信回调)。
    *   Nginx 或 Caddy 作为反向代理 (推荐)。

## 7. 未来规划 (可选)

*   **支持更复杂的查询:** 如基于技能相似度的查询、排除特定条件等。
*   **简历解析优化:** 支持更多格式 (Word), 提高准确率, 进行深层分析 (打分)。
*   **多轮对话:** 实现更智能的交互，如澄清模糊查询。
*   **状态跟踪:** 跟踪与候选人的沟通状态。
*   **Web 管理界面:** 管理用户、配置、日志、数据库、失败简历等。
*   **与其他 HR 系统集成:** 对接 ATS。
*   **自动化简历处理:** 目录监控自动触发。

