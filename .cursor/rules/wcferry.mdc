---
description: 
globs: 
alwaysApply: true
---
**注意：本文档描述的是本项目基于 `wcferry` 的早期版本实现。项目当前已迁移到企业微信自建应用框架。企业微信版本的架构和实现请参考其他相关文档 (如 `architecture.mdc`, `prd.mdc` 等)。**

# wcferry 调用指南 (基于 lich0821/WeChatRobot 分析)

本指南总结了在 `lich0821/WeChatRobot` 项目中观察到的 `wcferry` 核心 API 的使用方法，旨在帮助开发者快速上手 `wcferry`。

## 1. 初始化与清理

在使用 `wcferry` 的任何功能之前，需要先初始化 `Wcf` 类实例。在程序结束时，应调用 `cleanup` 方法释放资源。

```python
from wcferry import Wcf
import signal
import time

# 初始化，可传入 debug=True 开启调试日志
wcf = Wcf(debug=True)

def handler(sig, frame):
    print("程序退出，执行清理...")
    wcf.cleanup()  # 退出前清理环境
    exit(0)

# 监听 Ctrl+C 信号，确保程序退出时清理
signal.signal(signal.SIGINT, handler)

# 获取机器人自身 wxid (v1.1 中用于判断群聊是否@自己)
my_wxid = wcf.get_self_wxid()
print(f"机器人 Wxid: {my_wxid}")

# ... 其他机器人逻辑 ...

# 阻塞主线程，例如
# while True:
#     time.sleep(1)
```

## 2. 消息接收

`wcferry` 提供两种主要的消息接收方式：

### 方式一：队列接收 (推荐)

这种方式通过内部队列缓冲消息，在单独的线程中获取和处理，通常更稳定。**v1.1 采用此方式。**

```python
from wcferry import Wcf, WxMsg
from queue import Empty
from threading import Thread
import logging

logging.basicConfig(level=logging.INFO)
LOG = logging.getLogger("MsgHandler")

wcf = Wcf(debug=True)

def process_msg(msg: WxMsg):
    """处理具体消息的逻辑"""
    LOG.info(f"收到消息: {msg}") # 打印原始消息对象
    # --- 根据消息类型和内容进行处理 ---
    if msg.is_text(): # 文本消息
        print(f"收到文本消息: {msg.content}")
        # 回复收到的文本 (v1.1 中会由核心逻辑处理)
        if msg.from_group():
             # 如果是群消息，@发送者并回复 (v1.1 实现的关键点)
             # 注意 get_alias_in_chatroom 用于获取昵称
             wcf.send_text(f"@{wcf.get_alias_in_chatroom(msg.sender, msg.roomid)} 收到了你的消息: {msg.content}", msg.roomid, msg.sender)
        else:
             # 如果是私聊消息，直接回复
             wcf.send_text(f"收到了你的消息: {msg.content}", msg.sender)

    # --- 其他消息类型判断 ---
    # ...

def message_listener():
    """消息监听线程"""
    while wcf.is_receiving_msg():
        try:
            msg = wcf.get_msg() # 从队列获取消息
            # 在 v1.1 中，这里会将 msg 传递给 core_processor 进行分发处理
            process_msg(msg)    # 示例：直接处理消息
        except Empty:
            continue # 队列空，继续等待
        except Exception as e:
            LOG.error(f"处理消息时发生错误: {e}")

# 启动消息接收，这会告诉 wcferry 开始将消息放入内部队列
wcf.enable_receiving_msg()

# 启动消息处理线程 (v1.1 中，这里启动的是核心处理器的监听循环)
thread = Thread(target=message_listener, name="MsgListener")
thread.daemon = True
thread.start()

print("消息接收已启动...")
# 主线程需要保持运行，否则程序会退出
while True:
    time.sleep(1)

```

### 方式二：直接回调

将一个处理函数直接注册给 `wcferry`。当有新消息时，`wcferry` 会直接调用这个函数。

```python
from wcferry import Wcf, WxMsg
import logging

logging.basicConfig(level=logging.INFO)
LOG = logging.getLogger("MsgCallback")

wcf = Wcf(debug=True)

def on_message_callback(msg: WxMsg) -> int:
    """消息回调函数"""
    try:
        LOG.info(f"Callback 收到消息: {msg}")
        # 在这里添加你的消息处理逻辑，与 process_msg 类似
        if msg.is_text():
            print(f"Callback 收到文本: {msg.content}")
            # ... 回复逻辑 ...
        # ... 其他消息类型处理 ...
    except Exception as e:
        LOG.error(f"Callback 处理消息出错: {e}")
    return 0 # 返回 0 表示处理成功

# 启用消息接收，并注册回调函数
wcf.enable_recv_msg(on_message_callback)

print("直接回调消息接收已启动...")
# 阻塞主线程
wcf.keep_running() # wcferry 提供了一个便捷的方法来阻塞
```

## 3. 消息处理 (`WxMsg` 对象)

无论是哪种接收方式，你都会得到一个 `WxMsg` 对象，它包含了消息的各种信息：

*   `msg.type`: 消息类型 (整数，例如 1 是文本，3 是图片等)。
*   `msg.id`: 消息 ID。
*   `msg.xml`: 原始消息的 XML 内容。
*   `msg.sender`: 发送者的 wxid。
*   `msg.roomid`: 如果是群消息，表示群的 ID；否则为空。**(v1.1 用于区分群聊)**
*   `msg.content`: 消息内容。
*   `msg.thumb`: 缩略图的本地路径。
*   `msg.extra`: 额外信息。
*   `msg.is_at(wxid)`: 判断消息是否 @ 了指定的 `wxid`。**(v1.1 用于判断是否 @机器人)**
*   `msg.is_text()`: 判断是否为文本消息。**(v1.1 主要处理文本)**
*   `msg.from_group()`: 判断消息是否来自群聊。**(v1.1 用于区分群聊)**
*   `msg.from_self()`: 判断消息是否由自己发送。**(v1.1 用于忽略自身消息)**

## 4. 发送消息

`wcferry` 提供了发送不同类型消息的 API：

### 发送文本

```python
# 发送私聊消息
wcf.send_text("你好，这是一条私聊消息。", "filehelper") # 发送到文件传输助手

# 发送群聊消息
group_id = "xxxxxxxx@chatroom" # 替换为你的群 ID
wcf.send_text("大家好，这是一条群消息。", group_id)

# 发送群聊消息并 @ 单个人 (v1.1 核心用法)
friend_wxid = "wxid_xxxxxxxxxxxx" # 替换为你要 @ 的好友 wxid
# 注意：第三个参数 receiver 是要 @ 的人 (单个 wxid 字符串)
# 文本中需要包含 @昵称，使用 get_alias_in_chatroom 获取
wcf.send_text(f"@{wcf.get_alias_in_chatroom(friend_wxid, group_id)} 你好！", group_id, friend_wxid)

# 发送群聊消息并 @ 多个人
# 注意：receiver 参数是逗号分隔的 wxid 字符串
friend_wxid_1 = "wxid_xxxxxxxxxxxx1"
friend_wxid_2 = "wxid_xxxxxxxxxxxx2"
at_list = f"{friend_wxid_1},{friend_wxid_2}"
# 文本中需要包含对应数量的 @昵称
ats = f"@{wcf.get_alias_in_chatroom(friend_wxid_1, group_id)} @{wcf.get_alias_in_chatroom(friend_wxid_2, group_id)}"
wcf.send_text(f"{ats}\n 这是一条@多个人的消息", group_id, at_list)


# 发送群聊消息并 @ 所有人
# 注意：需要群主或管理员权限
# receiver 固定为 "notify@all"
wcf.send_text("@所有人 重要通知！", group_id, "notify@all")
```

### 发送图片

```python
image_path = "path/to/your/image.png" # 替换为本地图片路径
receiver_wxid = "filehelper" # 或群 ID

# 检查文件是否存在
import os
if os.path.exists(image_path):
    result = wcf.send_image(image_path, receiver_wxid)
    if result == 0:
        print("图片发送成功")
    else:
        print(f"图片发送失败，错误码: {result}")
else:
    print(f"图片文件不存在: {image_path}")

```

### 发送文件 (类似图片)

**(v1.1 用于按需发送简历)**

```python
file_path = "path/to/your/document.pdf" # 替换为本地文件路径
receiver_wxid = "filehelper"

import os
if os.path.exists(file_path):
    result = wcf.send_file(file_path, receiver_wxid)
    if result == 0:
        print("文件发送成功")
    else:
        print(f"文件发送失败，错误码: {result}")
else:
    print(f"文件不存在: {file_path}")
```

## 5. 好友与群聊操作

### 接受好友请求

(v1.1 未使用此功能)

```python
import xml.etree.ElementTree as ET

def autoAcceptFriendRequest(msg: WxMsg):
    try:
        xml_content = msg.xml if msg.xml else msg.content
        xml = ET.fromstring(xml_content)
        v3 = xml.attrib["encryptusername"]
        v4 = xml.attrib["ticket"]
        scene = int(xml.attrib.get("scene", 30))

        result = wcf.accept_new_friend(v3, v4, scene)
        if result == 0:
            print(f"成功接受好友请求: {v3}")
        else:
            print(f"接受好友请求失败: {v3}, 错误码: {result}")

    except Exception as e:
        print(f"处理好友请求出错：{e}")
```

### 获取群成员昵称

用于在发送 @ 消息时显示正确的昵称。**(v1.1 用于群聊 @ 回复)**

```python
wxid_in_group = "wxid_xxxxxxxxxx"
group_id = "xxxxxxxx@chatroom"
nickname = wcf.get_alias_in_chatroom(wxid_in_group, group_id)
print(f"用户 {wxid_in_group} 在群 {group_id} 中的昵称为: {nickname}")
```

## 6. 获取信息

### 获取联系人列表 (通过数据库查询)

(v1.1 未直接使用此功能查询联系人，但后台可能需要)

```python
# 查询所有联系人的 Wxid 和 NickName
contacts_data = wcf.query_sql("MicroMsg.db", "SELECT UserName, NickName FROM Contact;")
contacts_dict = {contact["UserName"]: contact["NickName"] for contact in contacts_data}
# print(contacts_dict)

# 查询特定好友信息
friend_wxid = "wxid_xxxxxxxxxxxx"
friend_info = wcf.query_sql("MicroMsg.db", f"SELECT * FROM Contact WHERE UserName = '{friend_wxid}';")
# print(friend_info)
```
**注意**: 直接操作数据库需要了解微信数据库结构，且可能因微信版本更新而变化。

### 获取群列表

(v1.1 可能用于配置或调试)

```python
groups = wcf.get_chatrooms()
# print(groups) # 打印群列表信息
for group in groups:
    print(f"群ID: {group['wxid']}, 群名称: {group['name']}")
```

## 7. 定时任务

`wcferry` 内建了定时任务功能。`lich0821/WeChatRobot` 项目通过 `Job` 类进行了封装。以下是直接使用 `wcferry` 定时任务的示例：

(v1.1 未直接使用 wcferry 的定时任务，后台处理可能使用 APScheduler 或系统任务计划)

```python
import datetime

def scheduled_task():
    print(f"定时任务执行于: {datetime.datetime.now()}")
    wcf.send_text("这是一个定时发送的消息！", "filehelper")

# 每天 10:30 执行任务
wcf.add_cron_job("0", "30", "10", "*", "*", "*", scheduled_task)

# 每隔 1 小时执行任务
wcf.add_interval_job(scheduled_task, hours=1)

# 启动定时任务调度器 (如果尚未运行)
# wcf.keep_running()
```
**注意**: 定时任务接口可能因 `wcferry` 版本而异。

## 8. 保持运行

为了让机器人持续接收和处理消息以及执行定时任务，需要阻塞主线程。

```python
# 方法一：使用 wcferry 内建方法
wcf.keep_running()

# 方法二：手动循环 (v1.1 使用此方法，以便在主循环中处理消息分发)
# while True:
#     # 在这里添加消息获取和分发逻辑
#     time.sleep(1)
```
